import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { z } from "zod";
import { mkdirSync } from "fs";
import { execSync } from "child_process";
import { getClient } from "../temporal.js";
import type { PipelineInput } from "../types.js";

function sanitizeHostname(url: string): string {
  try {
    const hostname = new URL(url).hostname;
    return hostname.replace(/[^a-zA-Z0-9.-]/g, "_");
  } catch {
    return "unknown";
  }
}

/**
 * Translate a host path to its container-internal path.
 * The shannon CLI mounts TARGET_REPO â†’ /target-repo in the container.
 * If the path is already a container path, return as-is.
 */
function toContainerPath(hostPath: string): string {
  if (hostPath === "/target-repo" || hostPath.startsWith("/target-repo/")) {
    return hostPath;
  }
  if (hostPath.startsWith("/benchmarks/")) {
    return hostPath;
  }
  return "/target-repo";
}

/**
 * Ensure host directory exists and restart worker with correct mount.
 */
function ensureHostMount(hostPath: string): void {
  if (hostPath === "/target-repo" || hostPath.startsWith("/target-repo/") || hostPath.startsWith("/benchmarks/")) {
    return; // Already a container path, nothing to mount
  }

  // Create host directory if needed
  mkdirSync(hostPath, { recursive: true });

  // Restart worker with correct TARGET_REPO mount
  const shannonDir = process.env.SHANNON_PROJECT_DIR || `${process.env.HOME}/projects/shannon`;
  execSync(
    `TARGET_REPO=${hostPath} docker compose -f ${shannonDir}/docker-compose.yml up -d worker`,
    { cwd: shannonDir, stdio: "pipe", timeout: 30000 }
  );
}

export function registerStartPentest(server: McpServer): void {
  server.tool(
    "start_pentest",
    "Start a Shannon pentest workflow against a target URL with a local repository for code analysis. Returns the workflow ID for monitoring.",
    {
      webUrl: z.string().url().describe("Target URL to pentest (e.g. https://example.com)"),
      repoPath: z.string().describe("Absolute path to the target's source code repository (or a working directory for web-only audits)"),
      configPath: z.string().optional().describe("Path to YAML config file (for auth, TOTP, custom params)"),
      pipelineTestingMode: z.boolean().optional().describe("Use minimal prompts for fast testing (default: false)"),
    },
    async ({ webUrl, repoPath, configPath, pipelineTestingMode }) => {
      try {
        // Ensure host directory exists and is mounted in the container
        ensureHostMount(repoPath);

        const client = await getClient();

        const hostname = sanitizeHostname(webUrl);
        const workflowId = `${hostname}_shannon-${Date.now()}`;

        // Translate host path to container-internal path
        const containerPath = toContainerPath(repoPath);

        const input: PipelineInput = {
          webUrl,
          repoPath: containerPath,
          ...(configPath !== undefined && { configPath }),
          ...(pipelineTestingMode !== undefined && { pipelineTestingMode }),
        };

        await client.workflow.start("pentestPipelineWorkflow", {
          taskQueue: "shannon-pipeline",
          workflowId,
          args: [input],
        });

        const result = {
          workflowId,
          status: "started",
          hostPath: repoPath,
          containerPath,
          temporalWebUi: `http://localhost:8233/namespaces/default/workflows/${workflowId}`,
          monitorCommand: `./shannon query ID=${workflowId}`,
          logsCommand: `./shannon logs ID=${workflowId}`,
        };

        return {
          content: [{ type: "text" as const, text: JSON.stringify(result, null, 2) }],
        };
      } catch (err) {
        const message = err instanceof Error ? err.message : String(err);
        return {
          content: [{ type: "text" as const, text: `Failed to start pentest: ${message}` }],
          isError: true,
        };
      }
    }
  );
}
